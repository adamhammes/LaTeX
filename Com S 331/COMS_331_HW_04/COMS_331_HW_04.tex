\documentclass[11pt]{article}
\usepackage{enumerate}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{mathabx}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{parskip}
\usepackage{commath}

\begin{document}

\title{Com S 331 Assignment 4}
\author{Adam Hammes $\bullet$ hammesa@iastate.edu }
\maketitle

\section*{Problem 25}

The starting states can be any possible subset of $Q$, for a total of $\mathbb{P}(Q) = 2^n$ possible different starting states. Similarly, the accepting states are also any possible subset of $Q$, so there are $2^n$ possible different accepting states.

$\Delta$ maps a state/symbol tuple to a subset of $Q$. As discussed in lecture, the number of functions mapping from $a$ items to $b$ items is $n^m$; therefore we simply need to find $b$, the number of subsets of $Q$ and $a$, the number of possible state/symbol pairings.

There are $n$ states and 2 different symbols, thus the number of pairings $a$ is $2n$. As discussed in the first two paragraphs, the number of possible subsets $b= |\mathbb{P}(Q)| = 2^n$. Putting the two numbers together, the number of possible $\Delta$ is $(2^n)^{2n} = 2^{2n^2}$.

Now, these numbers are independent of each other- having a certain $S$ doesn't preclude options for $F$ for example- so to find the total number of NFAs with $Q = \{1, 2, \dots, n \}$ we simply multiply our three numbers together.
	\begin{align*}
		2^n \times 2^n \times 2^{2n^2} &= 2^{2n} \times 2^{2n^2} \\
		&= 2^{2n + 2n^2} \\
		&= 2^{2n(n+1)} \ \checkmark
	\end{align*}
	
\section*{Problem 26}

Prove that there is a language $A \subseteq \{0,1\}^*$ with both of the following properties:
	\begin{enumerate}[(i)]
		\item For all $x \in A$, $|x| \leq 7$.
		\item Every NFA that decides $A$ has more than 8 states.
	\end{enumerate}
	
Using only two symbols, the number of possible strings of length $n$ is $2^n$; allowing $n$ to be anywhere from 0 to 7, we find that there are 
	\[ \sum _{n=0} ^7 2^n = 255 \] 
strings of length seven or less. Our language contains some subset of these strings, so the number of possible languages $A$ is $2^{255}$.

Now, there are two facts we must consider about NFAs. 
	\begin{enumerate}[(1)]
		\item Any $n$ state NFA can be perfectly decided by an NFA with $n+1$ states, by copying the states of the former NFA and adding "junk" states that don't interact with the rest of the NFA. 
		
		Therefore \{languages decided by $n \leq 7$ state NFAs \} $\subset$ \{languages decided by 8 state NFAs\}.
		\item An NFA $N$ decides exactly one language, L($N$). This follows from the definition of what it means for an NFA to solve a language.
	\end{enumerate}

Consider an NFA with $n$ states. By (1), we need only consider for this problem the possible NFAs with exactly $n$ states, since all smaller $n$ is a subset. A formula for the number of such an NFA was found in the previous exercise. If the number of possible NFAs is less than $2^{255}$, than by the Pigeonhole Principle/(2)/(1), the NFAs cannot decide every language $A$. Because the number of NFAs with 8 states is $2^{2*8(8+1)} = 2^{144} < 2^{255}$, the NFAs cannot decide every possible language $A$; therefore we need more than 8 states. $\checkmark$

\section*{Problem 27}
Consider any finite language $A$. I construct an NFA $N = (Q, \Sigma, \Delta, S, F)$ that decides $A$.

First, let's define $Q$. The states of our automata are all the prefixes of the strings in $A$, including $\lambda$ and the strings themselves.

The starting/accepting states reveal a little more about the NFA. Our set of start states is simply the singleton set $\{\lambda\}$; we accept every string (remember that we are representing our states as strings) that is in $A$. This is more simply expressed as $F = A$.

Finally, we arrive at $\Delta$. Our definition of $\Delta$ is actually pretty simple- I'll write it formally then explain it.
	\[ \Delta( q \in Q, a \in \Sigma ) = \{ qa \mid \exists s \in A \text{ such that } qa \sqsubseteq s \} \]
In English, delta of a state (represented by a string)  and a symbol is the concatenation of the two, if that concatenation is a prefix of a string in $A$. If the concatenation is not such a prefix, then the delta of that state and symbol is not defined/$\emptyset$.

With our NFA now defined, let's examine what actually happens. As we feed in a string $s \in A$, our NFA follows down a chain of prefixes in increasing size, starting with $\lambda$, that eventually ends in the state $s$. $s \in A = F$, so the NFA accepts $s$. If we feed in a string that is not in $A$, we'll eventually reach a point where our NFA cannot find a suitable prefix in $Q$, and will jam.

Since our NFA solves $A$, and $A$ is any finite language, any finite language is regular.

\section*{Problem 28}

Let $A$ be $(01)^*\ ||\ (10)^*$. I define $A$ recursively:
	\begin{itemize}
		\item $\lambda \in A$
		\item If $s \in A$, $s \cdot 01 \in A$ and $s \cdot 10 \in A$, where $\cdot$ is the concatenation operator.
	\end{itemize}

\end{document}
\documentclass[11pt]{article}

\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}

\begin{document}

\title{Com S 331 Homework 7}
\author{Adam Hammes $\bullet$ hammesa@iastate.edu}
\date{October 22, 2014}
\maketitle

\section*{Problem 49}

Let $A$ be any infinitely large subset of $\{a^nb^n \mid n \geq 0\}$, $M = (Q, \Sigma, \delta, s, F)$ be any DFA. It suffices to prove that $L(M) \neq A$

 Since $A$ is infinitely large, $\exists s=a^jb^j \in A,$ where $j > |Q|$. Since $j > |Q|$, by the Pigeonhole Principle $M$ passes through a state $q \in Q$ at least twice while reading $a^j$. Let $a^k$ be the string that travels the same path as $a^j$, but skipping the states from the first $q$ up to and including the second $q$. Note that since we are always removing at least one state, the second $q$, $k < j$.

Because $a^k,\ a^j$ still end in the same state, $\hat{\delta}(a^k) = \hat{\delta}(a^j)$ which implies that by definition of $\hat{\delta}$ that $\hat{\delta}(a^jb^j) = \hat{\delta}(a^kb^j)$, so $M$ accepts both $a^ja^j$ and $a^ka^j$. However, $a^ka^j$ is clearly not in $A$ since $k \neq j$; therefore $L(M) \neq A$. $\checkmark$




\section*{Problem 50}

\begin{itemize}
	\item $Q = \{ s,\ a,\ b,\ c,\ t,\ r \}$
	\item $\Sigma = \{0,\ 1\}$
	\item $\Gamma = \{ \vdash,\ 0,\ 1,\ $\textvisiblespace$\}$
\end{itemize}

$\delta$ is defined according to the following table:

\begin{tabular}{ c | c | c | c | c }
			& $\vdash$ 			& 0 					& 1 				& \textvisiblespace \\
			\hline
	s		& a, $\vdash$, R 	& -					& -				& - \\
	a		& - 						& r, -, -				& b, 1, R		&  r, -, -\\
	b		& -						& b, 0, r			& b, 1, R		& c, \textvisiblespace , L \\
	c		& -						& t, -, -				& r, -, -			& -
\end{tabular}


\section*{Problem 51}

\begin{itemize}
	\item $Q = \{ s,\ a,\ b,\ c,\ t,\ r \}$
	\item $\Sigma = \{0,\ 1\}$
	\item $\Gamma = \{ \vdash,\ 0,\ 1,\ $\textvisiblespace$\}$
\end{itemize}

$\delta$ is defined according to the following table:


\begin{tabular}{ c | c | c | c | c }
			& $\vdash$				& 0 					& 1				& \textvisiblespace \\
		\hline
		s	& a, $\vdash$, R		& -					& -				& - \\
		a	& -							& b, 0, R			& a, 1, R		& r, -, - \\
		b	& -							& b, 0, R			& c, 1, R		& r, -, - \\
		c	& -							& t, -, -				& a, 1, R		& r, -, -
\end{tabular}


\section*{Problem 52}

\begin{itemize}
	\item $Q = \{ s,\ a,\ b,\ t,\ r \}$
	\item $\Sigma = \{0,\ 1\}$
	\item $\Gamma = \{ \vdash,\ 0,\ 1,\ $\textvisiblespace$\}$
\end{itemize}

$\delta$ is defined according to the following table:


\begin{tabular}{ c | c | c | c | c }
			& $\vdash$				& 0 					& 1				& \textvisiblespace \\
		\hline
		s	& a, $\vdash$, R		& -					& -				& - \\
		a	& -							& b, 0, R			& a, 1, R		& r, -, - \\
		b	& -							& r, -, -				& b, 1, R		& t, -, - \\
\end{tabular}

\section*{Problem 53}

Intuition: First, we check if there are 0 a's, in which case we reject, or 1 a, where we accept. Then our machine $M$ will erase all a's but the first, additionally marking the rightmost one with a b. 

Now we begin the loop; make the last a an \~a , letting us keep track of the original length. Then copy all the a's on the tape to the space right of \~a, up to and including \~a, effectively doubling the number of a's on the tape. If we try to overwrite our b with an \~a, accept because the original input had a power of two number of a's; if we overwrite b with a regular a, reject because the original input was not a power of two.





\section*{Problem 56}

Since $A$ and $B$ are recursive, there are Turing Machines that decide both of them, which I will call $M_A$ and $M_B$. I will construct a TM $N$ that decides $A \cup B$.

The first thing that $N$ does is to replace each symbol to the right of the left end-marker with a pair of the same symbols, vertically stacked. The top symbols will serve as a tape for $M_A$, and the bottom a tape for $M_B$.

The machine then simulates $M_A$ on the top tape symbols, moving the head as $M_A$ dictates and modifying the symbols as directed. If $M_B$ ever writes a symbol to a space that hasn't been divided up as in paragraph two, we do it as soon as $M_B$ writes the symbol. Since $A$ is recursive, $M_A$ is guaranteed to halt; once it does, we do one of two things depending on the halt state If $M_A$ accepted the string $x$, then $x \in A$ implying $x \in A \cup B$, so $N$ immediately accepts. 

If $M_A$ rejects, we repeat the previous process, this time with $M_B$ and the bottom side of the tape, which has not been touched since we first made the two tapes. Again, if $M_B$ accepts, so does $N$. However, this time if $M_B$ rejects, $N$ also rejects.

By simulating each machine separately, we can check if our string is in $A$ or in $B$; if it either, then we accept, else we reject. Therefore $N$ accepts an input iff the input is in $A \cup B$. $\checkmark$




\end{document}